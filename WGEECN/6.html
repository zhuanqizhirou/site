<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>列表</title>
<!-- 2018-09-29 周六 12:18 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">列表</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">在本章：</a></li>
<li><a href="#sec-2">列表初探</a></li>
<li><a href="#sec-3">列表细节</a></li>
<li><a href="#sec-4">递归列表函数</a></li>
<li><a href="#sec-5">迭代列表函数</a></li>
<li><a href="#sec-6">其他有用的列表函数</a></li>
<li><a href="#sec-7">破坏性列表操作</a></li>
<li><a href="#sec-8">循环列表？！</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">在本章：</h2>
<div class="outline-text-2" id="text-1">
<p>
<b>列表初探</b><br  />
<b>列表细节</b><br  />
<b>递归列表函数</b><br  />
<b>迭代列表函数</b><br  />
<b>其他有用的列表函数</b><br  />
<b>破坏性列表操作</b><br  />
<b>循环列表？！</b><br  />
</p>

<p>
目前为止，我们已经看到了一些列表（list）的使用，但是我们并没有真的去探索它们如何工作以及为什么它们如此有用。既然列表作为Lisp的核心内容，本章我们就来全面的观察一下这个数据结构。<br  />
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">列表初探</h2>
<div class="outline-text-2" id="text-2">
<p>
就像我们已经看到的，Lisp中的列表就是一个括号包裹起来的0个或多个Lisp表达式的序列。列表可以嵌套；也就是说括号里的子表达式还可以包含一个或多个列表。下面是一些例子：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(a b c) ; 三个符号组成的列表
(7 "foo") ; 一个数字和字符串组成的列表
((4.12 31178)) ; 列表只有一个元素：一个两个数字组成的自列表
</pre>
</div>

<p>
空列表()等价于符号nil。<br  />
</p>

<p>
函数car和cdr[<a href="#6-23">23</a>]用来访问列表的一部分：car得到列表的第一个元素，cdr得到列表剩下的元素（除第一个元素之外）。<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(car'(abc)) -&gt; a
(cdr'(abc)) -&gt; (b c)
(car (cdr '(a b c))) -&gt; b
</pre>
</div>

<p>
(回忆一下引用（quote）表达式&#x2013;可能是一个完整的列表&#x2013;表示按照字面来解释表达式。所以'(a b c)表示列表包含a、b、和c，而不是用b和c作为参数调用a)<br  />
</p>

<p>
只包含一个元素的列表的cdr为nil：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(cdr '(x)) -&gt; nil
</pre>
</div>

<p>
空列表的car和cdr都为nil：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(car '()) -&gt; nil
(cdr '()) -&gt; nil
</pre>
</div>

<p>
注意对于只包含nil的列表也是如此：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(car '(nil)) -&gt; nil
(cdr '(nil)) -&gt; nil
</pre>
</div>

<p>
但这并不表明()等价于(nil)。<br  />
</p>

<p>
对于这些你并不需要完全只听信我的言语。你只需要像<a href="1.html">第1章</a>中<a href="1.html#sec-7">执行Lisp表达式</a>章节中所描述的那样，到*scratch* buffer里自己尝试执行这些语句。<br  />
</p>

<p>
列表通过函数list，cons以及append创建。函数list可以使用任意数量的参数构建列表：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(list 'a "b" 7) -&gt; (a "b" 7)
(list '(x y z) 3) -&gt; ((x y z) 3)
</pre>
</div>

<p>
函数cons使用一个Lisp表达式和一个列表作为参数。它通过将表达式添加到列表的前面构成新列表：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(cons 'a '(3 4 5)) -&gt; (a 3 4 5)
(cons "hello" '()) -&gt; ("hello")
(cons '(a b) '(c d)) -&gt; ((a b) c d)
</pre>
</div>

<p>
注意对列表使用cons构建新列表并不会影响之前的列表：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq x '(a b c)) ;将(a b c)赋值给变量x
(setq y (cons 17 x)) ;cons 17给它并且赋值给y
y -&gt; (17 a b c) ;正常工作
x -&gt; (a b c) ;并不会改变x
</pre>
</div>

<p>
函数append使用任意数量的列表作为参数，并将其顶层元素连接成一个新列表。这会高效的去掉每个列表的外层括号，把剩下的元素放到一起，然后使用一对新的括号把它们括起来：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(append '(a b) '(c d)) -&gt; (a b c d)
(append '(a (b c) d) '(e (f))) -&gt; (a (b c) d e (f))
</pre>
</div>

<p>
函数reverse使用一个列表作为参数，将其顶层元素反转成为一个新的列表。<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(reverse '(a b c)) -&gt; (c b a)
(reverse '(1 2 (3 4) 5 6)) -&gt; (6 5 (3 4) 2 1)
</pre>
</div>

<p>
注意reverse并不会反转子列表中的元素。<br  />
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">列表细节</h2>
<div class="outline-text-2" id="text-3">
<p>
这一章节将解释Lisp中列表的内部工作机制。既然大部分Lisp程序都会不同程度的使用列表，理解它们的工作机制是很有益处的。这会让你理解列表擅长做什么、不擅长什么。<br  />
</p>

<p>
列表由更小的称为cons cells的数据结构构成。cons cell由两个Lisp表达式构成，你可能并不惊讶如何访问它们&#x2013;使用car和cdr。<br  />
</p>

<p>
函数cons使用它的两个参数创建一个新的cons cell。不像前一小节中所讲的，cons的两个参数可以是任意Lisp表达式。第二个参数不能是一个已存在的列表。<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(cons 'a 'b) -&gt; 一个由car a和cdr b组成的cons cell
(car (cons 'a 'b)) -&gt; a
(cdr (cons 'a 'b)) -&gt; b
</pre>
</div>

<p>
生成的cons cell如图6-1所示。<br  />
</p>


<div class="figure">
<p><img src="resource/6-1.png" alt="6-1.png" /><br  />
</p>
</div>

<p>
图6-1 (cons 'a 'b)的结果<br  />
</p>

<p>
当你将一些其他元素与一个列表执行cons时，例如<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(cons 'a '(b c))
</pre>
</div>

<p>
结果是(a b c)，也就是一个car为a，cdr为(b c)的cons cell。后面会更详细的讲述它。<br  />
</p>

<p>
对于cdr不是列表的cons cell有一种特殊的语法。它被称为dotted pair notation，而cons cells有时也被称为dotted pairs：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(cons a b) -&gt; (a . b)
(cons '(1 2) 3) -&gt; ((1 2) . 3)
</pre>
</div>

<p>
当如图6-2所示的那样，一个cons cell的cdr为nil时，可以省略掉点号和nil。<br  />
</p>

<p>
<img src="resource/6-2.png" alt="6-2.png" /><br  />
图6-2 一个单元素list(a)<br  />
</p>

<p>
另一个省略的规则是当cons cell的cdr是另一个cons cell时，那么点号以及包裹cdr的括号都可以省略。见图6-3。<br  />
</p>

<p>
<img src="resource/6-3.png" alt="6-3.png" /><br  />
图6-3 一个cons cell指向另一个<br  />
</p>

<p>
当把这条规则和前一条忽略cdr为nil的规则组合起来的时候，我们就会发现下面的列表我们已经很熟悉了：<br  />
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(a . (b . nil)) ≡ (a b . nil) ≡ (a b)
</pre>
</div>

<p>
通常来说，Lisp的列表是一个由cons cells组成的链表，每个cell的cdr是另一个cell，最后一个cell的cdr为空。cons cells的car是什么并不重要。图6-4展示了一个列表作为另一个列表的一部分存在。<br  />
</p>

<p>
<img src="resource/6-4.png" alt="6-4.png" /><br  />
图6-4 一个列表包含一个子列表<br  />
</p>

<p>
当你编写<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq x '(a b c))
</pre>
</div>

<p>
这会将x指向这个由三个cons cell组成的链表的第一个cell。如果你编写<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq y (cdr x)) ; 现在y是(b c)
</pre>
</div>

<p>
这会将y指向上面列表中的第二个cons cell。一个列表事实上只是一个指向cons cell的指针。<br  />
</p>

<p>
最后一个cdr不为nil的列表有时被称作improper list。通常association list总是improper lists。<br  />
</p>

<p>
有多个函数用来检测一个Lisp对象是列表还是组成列表的一部分。<br  />
</p>
<ul class="org-ul">
<li>consp检测它的参数是不是一个cons cell。对于(consp x)，当x为除空表之外的任何列表时返回true，其他返回false。<br  />
</li>
<li>atom检测它的参数是否为原子。(atom x)功能与(consp x)相反&#x2013;任何不是cons cell的元素，包括nil、数字、字符串以及符号都是原子。<br  />
</li>
<li>listp检测它的参数是否为列表。对于(listp x)，如果x为cons cells或者nil则返回true，其他返回false。<br  />
</li>
<li>null检测它的参数是否为nil。<br  />
</li>
</ul>

<p>
现在你已经知道了cons cells，你可能会觉得(car nil)和(cdr nil)都定义为nil很奇怪，因为nil甚至不是一个cnos cell，因此它也没有car和cdr。实际上，有一些Lisp方言在你对nil调用car和cdr时会报错。大多数Lisps的行为跟Emacs Lisp一样，主要是为了方便&#x2013;但是这个特例会造成一些奇怪的副作用，就像上面提到的，()和(nil)在car和cdr的时候的结果是一样的。<br  />
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">递归列表函数</h2>
<div class="outline-text-2" id="text-4">
<p>
传统的Lisp教材使用一系列简短的编程练习来阐明列表和cons cells的行为。让我们花一点时间看一下两个广为人知的例子，然后再往下进行。<br  />
</p>

<p>
在这个练习中我们的目标是定义一个名为flatten的函数，将指定的列表的所有内部的子列表都释放出来平铺到一层上。例如：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(flatten '(a ((b) c) d)) -&gt; (a b c d)
</pre>
</div>

<p>
解决方案是使用递归，将car和cdr分别平铺，然后将他们合并到一层上来。假如输入的列表为<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">((a (b)) (c d))
</pre>
</div>

<p>
它的car是(a (b))，平铺之后是(a b)。cdr是((c d))，平铺之后的结果是(c d)。函数append可以将(a b)和(c d)组合起来并且保持平铺，结果是(a b c d)。所以flatten的核心代码是：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(append (flatten (car lst))
        (flatten (cdr lst)))
</pre>
</div>

<p>
（我将lst作为flatten的参数名称。不能使用list，因为它是一个Lisp函数的名称）现在，flatten只能对列表工作，所以对于(flatten (car lst))，如果(car lst)不是一个列表的话将会报错。我们因此需要这么改进：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(if (listp (car lst))
    (append (flatten (car lst))
            (flatten (cdr lst))))
</pre>
</div>

<p>
这个if没有“else”分支。如果(car lst)不是列表怎么办？例如，假设lst为<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(a ((b) c))
</pre>
</div>

<p>
car不是一个列表。这时，我们只要简单的平铺cdr，(((b) c))，得到(b c)；然后用cons将car组装上去。<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(if (listp (car lst))
    (append (flatten (car lst))
            (flatten (cdr lst)))
  (cons (car lst)
        (flatten (cdr lst))))
</pre>
</div>

<p>
最后，我们需要一个方法来终止这个递归。在处理列表越来越小的分片的递归函数里，你能用来作为结束分片的最小分片是nil，而nil几乎总是作为这种函数的“默认选择”。在本例中，平铺nil的结果就是nil，所以完整的函数定义为<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(defun flatten (lst)
  (if (null lst) ; lst是nil吗？
      nil ; 是的话，返回nil
    (if (listp (car lst))
        (append (flatten (car lst))
                (flatten (cdr 1st)))
      (cons (car 1st)
            (flatten (cdr 1st))))))
</pre>
</div>

<p>
试着在*scratch* buffer里用这个函数处理一些列表，并且试着通过一些例子来理清函数逻辑。记住Lisp函数的返回值是其最后执行的表达式的值。<br  />
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">迭代列表函数</h2>
<div class="outline-text-2" id="text-5">
<p>
递归并不总是列表相关编程问题的正确解决方案。有时朴实直接的迭代也是需要的。在本例中，我们将会展示Emacs Lisp每次处理列表中一个元素的语法风格，有时这也被称为列表的“cdr-ing down”（因为每次迭代，列表都会因取其cdr而缩短）。<br  />
</p>

<p>
假设我们需要一个用来计数列表中符号个数，并且跳过像数字、字符串和子列表等其他元素的函数。这个递归函数是错误的：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(defun count-syms (lst)
  (if (null lst)
      0
    (if (symbolp (car lst))
        (+ 1 (count-syms (cdr lst)))
      (count-syms (cdr lst)))))
</pre>
</div>

<p>
递归&#x2013;特别是深度递归&#x2013;引入了非常多的额外资源来记录嵌套函数的调用和返回值，而这些应该尽量避免。而且，这个问题用迭代的方式解决显然更合理，而代码通常应该反映出解决问题的合理方式，而不是自作聪明地将解决问题地方式复杂化。<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(defun count-syms (lst)
  (let ((result 0))
    (while lst
      (if (symbolp (car lst))
          (setq result (+ 1 result)))
      (setq lst (cdr lst)))
    result))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">其他有用的列表函数</h2>
<div class="outline-text-2" id="text-6">
<p>
下面是其他一些Emacs定义的列表相关函数。<br  />
</p>
<ul class="org-ul">
<li>length返回列表的长度。对于improper list它不会工作。<br  />
<div class="org-src-container">

<pre class="src src-emacs-lisp">(length nil) -&gt; 0
(length '(x y z)) -&gt; 3
(length '((x y z))) -&gt; 1
(length '(a b . c)) -&gt; error
</pre>
</div>
</li>

<li>nthcdr对列表调用n次cdr。<br  />
<div class="org-src-container">

<pre class="src src-emacs-lisp">(nthcdr 2 '(a b c)) -&gt; (c)
</pre>
</div>
</li>

<li>nth返回列表的第n个元素（第一个元素序号为0）。这与nthcdr的car等价。<br  />
<div class="org-src-container">

<pre class="src src-emacs-lisp">(nth 2 '(a b c))-&gt; c
(nth 1 '((a b) (c d) (e f))) -&gt; (c d)
</pre>
</div>
</li>

<li>mapcar使用一个函数和一个列表作为参数。它对列表包含的每个元素都调用一次函数，即将列表里的元素作为参数传给那个函数。mapcar的返回值是一个包含对每个元素调用函数之后的列表。所以如果你有一个字符串列表而你想要让其中的字符串首字母大写的话，可以这么写：<br  />
<div class="org-src-container">

<pre class="src src-emacs-lisp">(mapcar '(lambda (x)
           (capitalize x))
        ("lisp" "is" "cool")) -&gt; ("Lisp" "Is" "Cool")
</pre>
</div>
</li>

<li>equal检测它的两个参数是否相等。它与<a href="3.html">第3章</a>中的章节<a href="3.html#sec-3-2">保存和取出point</a>中介绍的eq并不相同。不像eq判断它的参数是否为同一个对象，equal判断的是两个对象是否具有相同的结构和内容。<br  />

<p>
这个区别很重要。例如：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq x (list 1 2 3))
(setq y (list 1 2 3))
</pre>
</div>

<p>
x和y是两个不同的对象。也就是说，第一次调用list创建了一个包含三个cons cells的链表，而第二次创建了另外一个包含三个cons cells的链表。所以(eq x y)值为nil，即使两个列表实际上包含着相同的结构和内容。也因此，(equal x y)为true。<br  />
</p>

<p>
在Lisp编程中，每当你希望判断两个对象是否相等时，你都需要注意调用eq还是equal更合适。另一点需要注意的是eq是一个瞬发操作，而equal可能需要递归比较两个参数的内部结构。<br  />
</p>

<p>
注意下面的eq值为true。<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq x (list 1 2 3))
(setq y x)
(eq x y)
</pre>
</div>
</li>

<li>assoc会帮助你以键值的方式使用列表。当列表的形式为<br  />
<div class="org-src-container">

<pre class="src src-emacs-lisp">((key1 . value1)
 (key2 . value2)
 ...
 (keyn . valuen))
</pre>
</div>

<p>
被称为association list，或者简写为assoc list[<a href="#6-24">24</a>]。函数assoc会找到列表中第一个的car为指定参数的子列表。所以：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(assoc 'green
        '((red . "ff0000")
        (green . "00ff00")
        (blue . "0000ff"))) -&gt; (green . "00ff00")
</pre>
</div>

<p>
如果没有匹配的子列表，assoc返回nil。<br  />
</p>

<p>
这个函数使用equal来检测每个键keyn是否匹配输入参数。另一个函数，assq，功能与assoc相同但是使用eq来做匹配。<br  />
</p>

<p>
有些程序员不喜欢使用dotted pairs，所以他们建立的字典看起来可能不是这样的：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">((red . "ff000")
 (green . "00ff00")
 (blue . "00ff"))
</pre>
</div>

<p>
而是这样的：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">((red "ff0000")
 (green "00ff00")
 (blue "000ff"))
</pre>
</div>

<p>
这没问题，因为对于assoc来说，列表中的每个元素仍然为dotted pair：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">((red . ("ff0000"))
(green . ("00ff00"))
(blue . ("0000ff")))
</pre>
</div>

<p>
唯一的区别是在前面的例子里，assoc list中的每一项都只需要储存在一个单独的cons cell里，而现在需要两个。而在前面的列表中获取与key匹配的值时只需要这么做：<br  />
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(cdr (assoc 'green ...)) -&gt; "00ff00"
</pre>
</div>

<p>
而现在必须这么做：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(car (cdr (assoc 'green ...))) -&gt; "00ff00"
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">破坏性列表操作</h2>
<div class="outline-text-2" id="text-7">
<p>
目前为止，我们所看到的所有列表操作都是非破坏性的。例如，当你把一个对象cons到一个已存在的列表上时，结果是产生了一个全新的cons cell，它的cdr指向了原来未做改动的列表。任何其他引用之前列表的对象或变量都未受影响。同样的，append会创建一个新列表以及新cons cells来保存参数中列表的元素。它不会将x最后的cdr指向y，或者将y最后的cdr指向z，因为这样的话最后的nil指针就改变了。而这样的话就影响了x和y原来的使用。实际上append对这些列表分别创建了一个未命名的拷贝，如图6-5所示。注意z不需要拷贝；append总是直接使用最后一个参数[<a href="#6-25">25</a>]。<br  />
</p>

<p>
<img src="resource/6-5.png" alt="6-5.png" /><br  />
图 6-5： append函数不会影响它的参数<br  />
</p>

<p>
下面是非破坏性的append在Lisp代码中的表示：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq x '(a b c))
(setq y '(d e f))
(setq z '(g h i))
(append x y z) -&gt; (a b c d e f g h i)
</pre>
</div>

<p>
因为append并不会修改它的参数，所以这些变量储存的仍然是之前的值：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">x -&gt; (a b c)
y -&gt; (d e f)
z -&gt; (g h i)
</pre>
</div>

<p>
但是如果做出了破坏性的修改，那么每个变量都会指向append时制作出的长链表的一部分，如图6-6所示。执行破坏性append的函数称为nconc。<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(nconc x y z) -&gt; (a b c d e f g h i)
x -&gt; (a b c d e f g h i)
y -&gt; (d e f g h i)
z -&gt; (g h i)
</pre>
</div>

<p>
<img src="resource/6-6.png" alt="6-6.png" /><br  />
图6-6 不像append， nconc会影响它的参数<br  />
</p>

<p>
通常破坏性的修改列表并不明智。很多其他的变量和数据结构可能正在使用你修改的列表，所以最好不要修改它以致造成不可预知的影响。<br  />
</p>

<p>
另一方面，有时你确实希望破坏性的修改一个列表。可能你希望利用nconc的高效并且你确实地知道没有其他代码会因为列表的改变而受到影响。<br  />
</p>

<p>
使用破坏性操作的最常见的一个场景是改变assoc list中的值。例如，假如你有一个对应保存着人员名称和它们email的assoc list：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq e-addrs
      '(("robin" . "rl@sherwood.uk")
        ("marian" . "mf@sherwood.uk")
        ...))
</pre>
</div>

<p>
现在假设有人的email地址改变了。你需要这样来更新它：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq e-addrs (alist-replace e-addrs "john" "johnl@exile.fr"))
</pre>
</div>

<p>
而alist-replace实际上是一个非常低效地递归操作，它的机制是重新拷贝整个列表：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(defun alist-replace (alist key new-value)
  (if (null alist)
      nil
    (if (and (listp (car alist))
             (equal (car (car alist))
                    key))
        (cons (cons key new-value)
              (cdr alist))
      (cons (car alist)
            (alist-replce (cdr alist) key new-value)))))
</pre>
</div>

<p>
不仅仅是低效（特别是当输入很大时），而且有可能你确实希望改变任何引用这个数据结构的对象和变量。显然，alist-replace并没有改变原数据结构。它创建了一个全新的拷贝，而任何引用老数据的对象都没有得到更新。以代码来表示这种情况就是：<br  />
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq alist '((a . b) (c . d))) ; alist 是一个 assoc list.
(setq alist-2 alist) ; alist-2 指向了同一个列表
(setq alist (alist-replace alist 'c 'q)) ; alist 是一个新列表
alist -&gt; ((a . b) (c . q)) ;alist 响应了改动
alist-2 -&gt; ((a . b) (c . d)) ;alist-2 仍然指向之前的列表
</pre>
</div>

<p>
这里引入setcar和setcdr[<a href="#6-26">26</a>]。给出一个cons cell和一个新值，这两个函数会将cell的car或者cdr替换为新值。例如：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq x (cons 'a 'b)) -&gt; (a . b)
(setcar x 'c)
x -&gt; (c . b)
(setcdr x 'd)
x -&gt; (c . d)
</pre>
</div>

<p>
我们现在可以轻松的编写alist-replace的破坏性版本了：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(defun alist-replace (alist key new-value)
  (let ((sublist (assoc key alist)))
    (if sublist
        (setcdr sublist new-value))))
</pre>
</div>

<p>
这会查找alist的子列表中谁的car与key匹配&#x2013;例如，("john" . "jl@nottingham.co.uk")&#x2013;并且将cdr替换为new-value。而由于这会改变原数据结构&#x2013;也就是说，这并没有创建任何新的拷贝&#x2013;所有引用这个cons cell的的变量和其他对象，特别是包含它的assoc list，都会反映出这个改变。<br  />
</p>

<p>
还有另一个重要的破坏性列表操作：nreverse，reverse的非拷贝版本。<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq x '(a b c))
(nreverse x) -&gt; (c b a)
x -&gt; (a)
</pre>
</div>

<p>
为什么上面的例子中最后x等于(a)呢？这是因为x仍然指向同一个cons cell，在前面的操作中已经倒转过来了。(a b c)由三个cons cells组成，car分别为a、b、c。一开始，x是通过指向链表的第一个cons cell引用列表的&#x2013;它的car为a而cdr指向下一个cons cell（也就是包含b的那个cell）。但是在nreverse之后，所有cons cells的cdrs都变了。现在car为c的cons cell变为了链表的第一个元素，而它的cdr变成了包含b的cons cell。同时，x的值却没变：它仍然指向之前的cons cell，也就是car为a的cell。但是现在这个cell由于变成了链表的末尾，所以cdr却变成了nil。因此，x等价于(a)。<br  />
</p>

<p>
如果你需要x也适应列表的改变，那么你必须这么写<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq x (nreverse x)) -&gt; (c b a)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">循环列表？！</h2>
<div class="outline-text-2" id="text-8">
<p>
由于我们可以破坏性地修改我们创建的列表，我们就可以不受只用预定义元素构建列表的限制。列表可以引用自己的一部分！例如：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq x '(a b c))
(nthcdr 2 x) -&gt; (c)
(setcdr (nthcdr 2 x) x) ;先不要这么做！
</pre>
</div>

<p>
这个例子会发生什么呢？开始我们创建了一个包含三个元素的列表并且将其赋给x。然后我们通过nthcdr找到最后一个cons cell。最后，我们将这个cell的cdr替换为x&#x2013;也就是这个列表中的第一个cell。现在这个list变成环了：之前的列表的尾巴指回了头部。<br  />
</p>

<p>
这个列表长什么样呢？好吧，它的开头看起来是这样的：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(a b c ab c ab c a b c a b c a b c a b c a b c . . .
</pre>
</div>

<p>
而这永远不会停止。我在上面写“先不要这么做！”的原因是如果你在*scratch* buffer里执行这段代码的话，Emacs将会试着去显示结果&#x2013;而这永远不可能完成。这将会进入一个死循环，虽然你可以用C-g终止这个过程。现在你可以去试试了，当然在Emacs卡死之后尽快按下C-g。你等的时间越久，*scratch* buffer中填充的a b c就越多。<br  />
</p>

<p>
显然，打印并不是环状结构能把Emacs搞得无限循环的唯一一件事。任何迭代执行这个列表里所有元素的动作都不会终止。下面是一个很好的例子：<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(eq x (nthcdr 3 x)) -&gt; t ; 第三个cdr与x指向同一个对象
(equal x (nthcdr 3 x)) -&gt;  永不停止！
</pre>
</div>

<p>
既然循环列表会导致Emacs进入无限循环，那它有什么用呢？通常我们都不会想让列表变为环状，但是如果你不将其认为是列表，而是相互连接在一起的cons cells的话，你就可以构建任何种类的链表结构了，比如树和lattices。有些数据结构是自引用的，例如环。如果你曾经需要构建这类数据结构的话，你就不会被Emacs可能会为了显示它而造成无限循环这件事吓倒了。不要在需要展示结果的情况下使用它就可以了。例如，如果你将上面的setcdr改为下面这样<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(setqx '(a b c))
(progn
  (setcdr (nthcdr 2 x) x)
  nil)
</pre>
</div>

<p>
那么Emacs将不会尝试展示setcdr的结果，而现在x就是一个我们可以操作的但是却不用全部展示的环状数据结构了。<br  />
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(nth 0 x) -&gt; a
(nth 1 x) -&gt; b
(nth 412 x) -&gt; b
</pre>
</div>

<p>
<a id="6-23" name="6-23"></a><sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>. 读作“could-er”。这些名称是最初Lisp设计时电脑架构的历史遗留。<br  />
<a id="6-24" name="6-24"></a><sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup>. 我一直找不到统一的读法到底应该是a-SOAK，a-SOASH或者a-SOCK list。这三种我都听到过。有些人会将其读作“a-list”来避免这个问题。<br  />
<a id="6-25" name="6-25"></a><sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup>. 因为是直接指向的，所以append的最后一个参数甚至不用是一个列表！自己试试看。<br  />
<a id="6-26" name="6-26"></a><sup><a id="fnr.4" name="fnr.4" class="footref" href="#fn.4">4</a></sup>. 也称为rplaca和rplacd，跟car和cdr的历史原因相同。<br  />
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p>DEFINITION NOT FOUND.</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p>DEFINITION NOT FOUND.</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p>DEFINITION NOT FOUND.</p></div>

<div class="footdef"><sup><a id="fn.4" name="fn.4" class="footnum" href="#fnr.4">4</a></sup> <p>DEFINITION NOT FOUND.</p></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="date">Created: 2018-09-29 周六 12:18</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
